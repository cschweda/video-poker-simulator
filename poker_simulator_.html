<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Video Poker Simulator - Jacks or Better</title>
    <meta
      name="description"
      content="Professional video poker simulator with optimal strategy analysis and comprehensive statistics"
    />
    <meta
      name="keywords"
      content="video poker, jacks or better, poker simulator, casino games"
    />
    <link
      rel="icon"
      href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üÉè</text></svg>"
    />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
        font-family: "Orbitron", monospace;
        color: #fff;
        overflow-x: auto;
        min-height: 100vh;
      }

      .machine {
        max-width: 900px;
        margin: 20px auto;
        background: linear-gradient(145deg, #2c2c54, #40407a);
        border-radius: 20px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5),
          inset 0 1px 0 rgba(255, 255, 255, 0.1);
        padding: 30px;
        border: 3px solid #ffd700;
      }

      .header {
        text-align: center;
        margin-bottom: 30px;
      }

      .title {
        font-size: 2.5em;
        font-weight: 900;
        color: #ffd700;
        text-shadow: 0 0 20px #ffd700, 0 0 40px #ffd700;
        margin-bottom: 10px;
        animation: glow 2s ease-in-out infinite alternate;
      }

      @keyframes glow {
        from {
          text-shadow: 0 0 20px #ffd700, 0 0 40px #ffd700;
        }
        to {
          text-shadow: 0 0 30px #ffd700, 0 0 60px #ffd700, 0 0 80px #ffd700;
        }
      }

      .subtitle {
        font-size: 1.2em;
        color: #ff6b6b;
        font-weight: 700;
      }

      .display-panel {
        background: linear-gradient(145deg, #000, #1a1a1a);
        border: 3px solid #ffd700;
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 30px;
        box-shadow: inset 0 5px 15px rgba(0, 0, 0, 0.8);
      }

      .credits-display {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 10px;
        margin-bottom: 20px;
        font-size: 1.4em;
        font-weight: 700;
      }

      .credits,
      .bet,
      .winnings,
      .hands,
      .session {
        background: linear-gradient(145deg, #2c2c54, #1a1a2e);
        padding: 10px 20px;
        border-radius: 10px;
        border: 2px solid #4ecdc4;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        text-align: center;
      }

      .credits-value,
      .bet-value,
      .winnings-value,
      .hands-value,
      .session-value {
        color: #4ecdc4;
        font-size: 1.2em;
        text-shadow: 0 0 10px #4ecdc4;
        text-align: center;
        display: block;
        margin-top: 5px;
      }

      .card-area {
        margin-bottom: 30px;
      }

      .cards-container {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin-bottom: 20px;
        flex-wrap: wrap;
      }

      .card {
        width: 120px;
        height: 160px;
        background: linear-gradient(145deg, #fff, #f0f0f0);
        border: 3px solid #333;
        border-radius: 12px;
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        align-items: center;
        font-size: 1.1em;
        font-weight: bold;
        color: #333;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        position: relative;
        overflow: hidden;
      }

      .card.flipping {
        animation: flip 0.6s ease-in-out;
      }

      @keyframes flip {
        0% {
          transform: rotateY(0deg);
        }
        50% {
          transform: rotateY(90deg);
        }
        100% {
          transform: rotateY(0deg);
        }
      }

      .card.held {
        border-color: #ffd700;
        box-shadow: 0 0 20px #ffd700, 0 8px 16px rgba(0, 0, 0, 0.3);
        transform: translateY(-10px);
      }

      .card.red {
        color: #e74c3c;
      }

      .card-back {
        background: radial-gradient(circle at 30% 30%, #1a472a, transparent 50%),
          radial-gradient(circle at 70% 70%, #1a472a, transparent 50%),
          linear-gradient(45deg, #2d5a35 25%, transparent 25%),
          linear-gradient(-45deg, #2d5a35 25%, transparent 25%),
          linear-gradient(45deg, transparent 75%, #2d5a35 75%),
          linear-gradient(-45deg, transparent 75%, #2d5a35 75%),
          radial-gradient(circle at center, #c0392b, #8b0000);
        background-size: 40px 40px, 40px 40px, 20px 20px, 20px 20px, 20px 20px,
          20px 20px, 100% 100%;
        background-position: 0 0, 20px 20px, 0 0, 10px 10px, 0 0, 10px 10px,
          center;
        color: #fff;
        justify-content: center;
        align-items: center;
        border: 3px solid #ffd700;
        position: relative;
        overflow: hidden;
      }

      .card-back::before {
        content: "";
        position: absolute;
        top: 10px;
        left: 10px;
        right: 10px;
        bottom: 10px;
        border: 2px solid #ffd700;
        border-radius: 8px;
      }

      .card-back::after {
        content: "‚ô†‚ô•‚ô¶‚ô£";
        position: absolute;
        font-size: 2em;
        color: #ffd700;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.8);
        font-weight: bold;
        letter-spacing: 3px;
      }

      .card-value {
        font-size: 1.4em;
        margin: 10px 0;
      }

      .card-suit {
        font-size: 2em;
        margin-bottom: 10px;
      }

      .hold-indicator {
        position: absolute;
        top: 5px;
        left: 50%;
        transform: translateX(-50%);
        background: #ffd700;
        color: #000;
        padding: 2px 8px;
        border-radius: 10px;
        font-size: 0.8em;
        font-weight: bold;
        display: none;
      }

      .card.held .hold-indicator {
        display: block;
      }

      .hand-result {
        text-align: center;
        font-size: 1.6em;
        font-weight: 700;
        margin: 20px 0;
        min-height: 40px;
        color: #ffd700;
        text-shadow: 0 0 15px #ffd700;
      }

      .controls {
        display: flex;
        justify-content: center;
        gap: 20px;
        margin-bottom: 30px;
        flex-wrap: wrap;
      }

      .btn {
        background: linear-gradient(145deg, #e74c3c, #c0392b);
        color: white;
        border: none;
        padding: 15px 30px;
        font-size: 1.1em;
        font-weight: 700;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s ease;
        box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
        font-family: "Orbitron", monospace;
        text-transform: uppercase;
        letter-spacing: 1px;
      }

      .btn:hover {
        transform: translateY(-3px);
        box-shadow: 0 12px 24px rgba(0, 0, 0, 0.4);
        background: linear-gradient(145deg, #ff6b6b, #e74c3c);
      }

      .btn:active {
        transform: translateY(0);
      }

      .btn:disabled {
        background: linear-gradient(145deg, #666, #555);
        cursor: not-allowed;
        transform: none;
      }

      .btn-deal {
        background: linear-gradient(145deg, #27ae60, #229954);
      }

      .btn-deal:hover {
        background: linear-gradient(145deg, #2ecc71, #27ae60);
      }

      .btn-max {
        background: linear-gradient(145deg, #f39c12, #e67e22);
      }

      .btn-max:hover {
        background: linear-gradient(145deg, #f1c40f, #f39c12);
      }

      .paytable {
        background: linear-gradient(145deg, #2c2c54, #1a1a2e);
        border: 2px solid #4ecdc4;
        border-radius: 15px;
        padding: 20px;
        margin-bottom: 20px;
      }

      .paytable h3 {
        color: #4ecdc4;
        text-align: center;
        margin-bottom: 15px;
        font-size: 1.3em;
        text-shadow: 0 0 10px #4ecdc4;
      }

      .paytable-grid {
        display: grid;
        grid-template-columns: 2fr repeat(5, 1fr);
        gap: 8px;
        font-size: 0.9em;
      }

      .paytable-header {
        background: linear-gradient(145deg, #4ecdc4, #45b7aa);
        color: #000;
        padding: 8px;
        text-align: center;
        font-weight: 700;
        border-radius: 5px;
      }

      .paytable-row {
        background: rgba(255, 255, 255, 0.1);
        padding: 8px;
        text-align: center;
        border-radius: 5px;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .paytable-hand {
        text-align: left;
        font-weight: 700;
        color: #ffd700;
      }

      .paytable-row.winning {
        background: linear-gradient(145deg, #ffd700, #f39c12) !important;
        color: #000 !important;
        font-weight: bold !important;
        box-shadow: 0 0 15px #ffd700;
        animation: pulse 1.5s ease-in-out infinite;
      }

      @keyframes pulse {
        0%,
        100% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.02);
        }
      }

      .settings {
        background: linear-gradient(145deg, #2c2c54, #1a1a2e);
        border: 2px solid #ff6b6b;
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
      }

      .settings h3 {
        color: #ff6b6b;
        text-align: center;
        margin-bottom: 15px;
        font-size: 1.3em;
        text-shadow: 0 0 10px #ff6b6b;
      }

      .settings-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
      }

      .setting-group {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .setting-label {
        display: block;
        margin-bottom: 8px;
        font-weight: 700;
        color: #4ecdc4;
      }

      .setting-input {
        width: 100%;
        padding: 8px;
        border-radius: 5px;
        border: 2px solid #4ecdc4;
        background: #1a1a2e;
        color: #fff;
        font-family: "Orbitron", monospace;
      }

      .simulation-panel {
        background: linear-gradient(145deg, #1a1a2e, #2c2c54);
        border: 2px solid #f39c12;
        border-radius: 15px;
        padding: 20px;
        margin-top: 20px;
      }

      .simulation-panel h3 {
        color: #f39c12;
        text-align: center;
        margin-bottom: 15px;
        font-size: 1.3em;
        text-shadow: 0 0 10px #f39c12;
      }

      .simulation-controls {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
      }

      .sim-control-group {
        background: rgba(255, 255, 255, 0.1);
        padding: 15px;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .progress-container {
        background: rgba(0, 0, 0, 0.5);
        border-radius: 10px;
        padding: 15px;
        margin: 15px 0;
        display: none;
      }

      .progress-container.active {
        display: block;
      }

      .progress-bar {
        width: 100%;
        height: 20px;
        background: #333;
        border-radius: 10px;
        overflow: hidden;
        margin-bottom: 10px;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #f39c12, #e67e22);
        width: 0%;
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 0.9em;
      }

      .sim-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 10px;
        margin-top: 15px;
      }

      .sim-stat {
        background: linear-gradient(145deg, #2c2c54, #1a1a2e);
        padding: 10px;
        border-radius: 8px;
        text-align: center;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .sim-stat-label {
        font-size: 0.8em;
        color: #aaa;
        margin-bottom: 5px;
      }

      .sim-stat-value {
        font-size: 1.2em;
        font-weight: bold;
        color: #f39c12;
      }

      .sim-current-hand {
        background: rgba(0, 0, 0, 0.3);
        padding: 10px;
        border-radius: 8px;
        margin: 10px 0;
        text-align: center;
        font-family: monospace;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .hand-frequency {
        display: grid;
        grid-template-columns: 2fr 1fr 1fr;
        gap: 5px;
        margin-top: 15px;
        font-size: 0.9em;
      }

      .freq-header {
        background: linear-gradient(145deg, #f39c12, #e67e22);
        color: #000;
        padding: 5px;
        text-align: center;
        font-weight: bold;
        border-radius: 3px;
      }

      .freq-row {
        display: contents;
      }

      .freq-cell {
        background: rgba(255, 255, 255, 0.1);
        padding: 5px;
        text-align: center;
        border-radius: 3px;
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .btn-simulation {
        background: linear-gradient(145deg, #f39c12, #e67e22);
        color: #000;
      }

      .btn-simulation:hover {
        background: linear-gradient(145deg, #f1c40f, #f39c12);
      }

      .simulation-graph {
        background: rgba(0, 0, 0, 0.5);
        border-radius: 10px;
        padding: 20px;
        margin-top: 20px;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }

      .simulation-graph canvas {
        border: 2px solid #f39c12;
        border-radius: 8px;
      }

      .rtp-display {
        text-align: center;
        margin-top: 15px;
        font-size: 1.1em;
        color: #ffd700;
        font-weight: 700;
      }

      @media (max-width: 768px) {
        .machine {
          margin: 10px;
          padding: 20px;
        }

        .title {
          font-size: 2em;
        }

        .credits-display {
          display: grid;
          grid-template-columns: 1fr 1fr 1fr;
          grid-template-rows: 1fr 1fr;
          gap: 8px;
        }

        .credits {
          grid-column: 1;
        }

        .bet {
          grid-column: 2;
        }

        .winnings {
          grid-column: 3;
        }

        .hands {
          grid-column: 1;
          grid-row: 2;
        }

        .session {
          grid-column: 2 / 4;
          grid-row: 2;
        }

        .card {
          width: 100px;
          height: 130px;
          font-size: 0.9em;
        }

        .controls {
          gap: 10px;
        }

        .btn {
          padding: 12px 20px;
          font-size: 1em;
        }

        .paytable-grid {
          font-size: 0.8em;
          gap: 5px;
        }
      }
    </style>
  </head>
  <body>
    <div class="machine">
      <div class="header">
        <div class="title">JACKS OR BETTER</div>
        <div class="subtitle">Video Poker</div>
      </div>

      <div class="display-panel">
        <div class="credits-display">
          <div class="credits">
            <div>CREDITS</div>
            <div class="credits-value" id="credits">5000</div>
          </div>
          <div class="bet">
            <div>BET</div>
            <div class="bet-value" id="bet">5</div>
          </div>
          <div class="winnings">
            <div>WIN</div>
            <div class="winnings-value" id="winnings">0</div>
          </div>
          <div class="hands">
            <div>HANDS</div>
            <div class="hands-value" id="hands">0</div>
          </div>
          <div class="session">
            <div>SESSION</div>
            <div class="session-value" id="session">0</div>
          </div>
        </div>

        <div class="hand-result" id="handResult">Press DEAL to start</div>
      </div>

      <div class="card-area">
        <div class="cards-container" id="cardsContainer">
          <div class="card card-back" data-index="0">
            <div class="hold-indicator">HELD</div>
          </div>
          <div class="card card-back" data-index="1">
            <div class="hold-indicator">HELD</div>
          </div>
          <div class="card card-back" data-index="2">
            <div class="hold-indicator">HELD</div>
          </div>
          <div class="card card-back" data-index="3">
            <div class="hold-indicator">HELD</div>
          </div>
          <div class="card card-back" data-index="4">
            <div class="hold-indicator">HELD</div>
          </div>
        </div>
      </div>

      <div class="controls">
        <button class="btn" id="betOne">BET ONE</button>
        <button class="btn btn-max" id="betMax">BET MAX</button>
        <button class="btn btn-deal" id="deal">DEAL</button>
        <button class="btn" id="drawBtn" disabled>DRAW</button>
      </div>

      <div class="paytable">
        <h3>PAYTABLE - CREDITS WON</h3>
        <div class="paytable-grid" id="paytableGrid">
          <div class="paytable-header">HAND</div>
          <div class="paytable-header">1</div>
          <div class="paytable-header">2</div>
          <div class="paytable-header">3</div>
          <div class="paytable-header">4</div>
          <div class="paytable-header">5</div>
        </div>
      </div>

      <div class="settings">
        <h3>MACHINE SETTINGS</h3>
        <div class="settings-grid">
          <div class="setting-group">
            <label class="setting-label">Paytable Variation:</label>
            <select class="setting-input" id="paytableVariation">
              <option value="full">Full Pay (99.54% RTP)</option>
              <option value="short">Short Pay (98.39% RTP)</option>
              <option value="bonus">Bonus Poker (99.17% RTP)</option>
            </select>
          </div>
          <div class="setting-group">
            <label class="setting-label">Reset Credits:</label>
            <input
              type="number"
              class="setting-input"
              id="resetCredits"
              value="5000"
              min="100"
              max="10000"
            />
            <button
              class="btn"
              id="resetBtn"
              style="margin-top: 10px; width: 100%; padding: 8px"
            >
              RESET
            </button>
          </div>
        </div>
        <div class="rtp-display" id="rtpDisplay">Current RTP: 99.54%</div>
      </div>

      <div class="simulation-panel">
        <h3>üé∞ SIMULATION MODE üé∞</h3>
        <div class="simulation-controls">
          <div class="sim-control-group">
            <label class="setting-label">Number of Hands:</label>
            <input
              type="number"
              class="setting-input"
              id="simHands"
              value="1000"
              min="100"
              max="100000"
            />
          </div>
          <div class="sim-control-group">
            <label class="setting-label">Speed (ms/hand):</label>
            <input
              type="number"
              class="setting-input"
              id="simSpeed"
              value="10"
              min="1"
              max="1000"
            />
          </div>
          <div class="sim-control-group">
            <label class="setting-label">Strategy:</label>
            <select class="setting-input" id="simStrategy">
              <option value="optimal">Optimal Play</option>
              <option value="random">Random Hold</option>
            </select>
          </div>
          <div class="sim-control-group">
            <button class="btn btn-simulation" id="startSim">
              START SIMULATION
            </button>
            <button class="btn btn-simulation" id="stopSim" disabled>
              STOP
            </button>
          </div>
        </div>

        <div class="progress-container" id="progressContainer">
          <div class="progress-bar">
            <div class="progress-fill" id="progressFill">0%</div>
          </div>
          <div class="sim-current-hand" id="currentHand">
            Ready to simulate...
          </div>

          <div class="sim-stats">
            <div class="sim-stat">
              <div class="sim-stat-label">Hands Played</div>
              <div class="sim-stat-value" id="simHandsPlayed">0</div>
            </div>
            <div class="sim-stat">
              <div class="sim-stat-label">Total Wagered</div>
              <div class="sim-stat-value" id="simWagered">0</div>
            </div>
            <div class="sim-stat">
              <div class="sim-stat-label">Total Won</div>
              <div class="sim-stat-value" id="simWon">0</div>
            </div>
            <div class="sim-stat">
              <div class="sim-stat-label">Net Result</div>
              <div class="sim-stat-value" id="simNet">0</div>
            </div>
            <div class="sim-stat">
              <div class="sim-stat-label">Actual RTP</div>
              <div class="sim-stat-value" id="simRTP">0%</div>
            </div>
            <div class="sim-stat">
              <div class="sim-stat-label">Win Rate</div>
              <div class="sim-stat-value" id="simWinRate">0%</div>
            </div>
          </div>

          <div class="hand-frequency">
            <div class="freq-header">Hand Type</div>
            <div class="freq-header">Count</div>
            <div class="freq-header">Frequency</div>

            <div class="freq-row">
              <div class="freq-cell">Royal Flush</div>
              <div class="freq-cell" id="freq-royal">0</div>
              <div class="freq-cell" id="freqp-royal">0%</div>
            </div>
            <div class="freq-row">
              <div class="freq-cell">Straight Flush</div>
              <div class="freq-cell" id="freq-straight-flush">0</div>
              <div class="freq-cell" id="freqp-straight-flush">0%</div>
            </div>
            <div class="freq-row">
              <div class="freq-cell">Four of a Kind</div>
              <div class="freq-cell" id="freq-four-kind">0</div>
              <div class="freq-cell" id="freqp-four-kind">0%</div>
            </div>
            <div class="freq-row">
              <div class="freq-cell">Full House</div>
              <div class="freq-cell" id="freq-full-house">0</div>
              <div class="freq-cell" id="freqp-full-house">0%</div>
            </div>
            <div class="freq-row">
              <div class="freq-cell">Flush</div>
              <div class="freq-cell" id="freq-flush">0</div>
              <div class="freq-cell" id="freqp-flush">0%</div>
            </div>
            <div class="freq-row">
              <div class="freq-cell">Straight</div>
              <div class="freq-cell" id="freq-straight">0</div>
              <div class="freq-cell" id="freqp-straight">0%</div>
            </div>
            <div class="freq-row">
              <div class="freq-cell">Three of a Kind</div>
              <div class="freq-cell" id="freq-three-kind">0</div>
              <div class="freq-cell" id="freqp-three-kind">0%</div>
            </div>
            <div class="freq-row">
              <div class="freq-cell">Two Pair</div>
              <div class="freq-cell" id="freq-two-pair">0</div>
              <div class="freq-cell" id="freqp-two-pair">0%</div>
            </div>
            <div class="freq-row">
              <div class="freq-cell">Jacks or Better</div>
              <div class="freq-cell" id="freq-jacks-better">0</div>
              <div class="freq-cell" id="freqp-jacks-better">0%</div>
            </div>
            <div class="freq-row">
              <div class="freq-cell">No Win</div>
              <div class="freq-cell" id="freq-no-win">0</div>
              <div class="freq-cell" id="freqp-no-win">0%</div>
            </div>
          </div>
        </div>

        <div
          class="simulation-graph"
          id="simulationGraph"
          style="display: none"
        >
          <h4
            style="
              color: #f39c12;
              text-align: center;
              margin-bottom: 15px;
              font-size: 1.2em;
            "
          >
            üìà Net Result Over Time
          </h4>
          <canvas
            id="resultChart"
            width="800"
            height="400"
            style="
              width: 100%;
              height: 300px;
              background: rgba(0, 0, 0, 0.3);
              border-radius: 8px;
            "
          ></canvas>
          <div
            style="
              text-align: center;
              margin-top: 10px;
              font-size: 0.9em;
              color: #aaa;
            "
          >
            Shows cumulative net result (credits won - credits wagered)
            throughout the simulation
          </div>
        </div>
      </div>
    </div>

    <script>
      // Clean, simple video poker game with simulation mode
      let gameState = {
        credits: 5000,
        startingCredits: 5000,
        bet: 5,
        currentWin: 0,
        handsPlayed: 0,
        sessionNet: 0,
        currentHand: [],
        heldCards: new Set(),
        gamePhase: "ready", // 'ready', 'holding', 'finished'
        deck: [],
      };

      // Simulation state
      let simState = {
        running: false,
        hands: 0,
        totalHands: 1000,
        wagered: 0,
        won: 0,
        handCounts: {
          "Royal Flush": 0,
          "Straight Flush": 0,
          "Four of a Kind": 0,
          "Full House": 0,
          Flush: 0,
          Straight: 0,
          "Three of a Kind": 0,
          "Two Pair": 0,
          "Jacks or Better": 0,
          "No Win": 0,
        },
        winningHands: 0,
        timeoutId: null,
        netHistory: [], // Track net result over time
        graphData: [],
      };

      const suits = ["‚ô†", "‚ô•", "‚ô¶", "‚ô£"];
      const ranks = [
        "A",
        "2",
        "3",
        "4",
        "5",
        "6",
        "7",
        "8",
        "9",
        "10",
        "J",
        "Q",
        "K",
      ];
      const rankValues = {
        A: 1,
        2: 2,
        3: 3,
        4: 4,
        5: 5,
        6: 6,
        7: 7,
        8: 8,
        9: 9,
        10: 10,
        J: 11,
        Q: 12,
        K: 13,
      };

      const paytables = {
        full: {
          name: "Full Pay Jacks or Better",
          rtp: 99.54,
          payouts: {
            "Royal Flush": [250, 500, 750, 1000, 4000],
            "Straight Flush": [50, 100, 150, 200, 250],
            "Four of a Kind": [25, 50, 75, 100, 125],
            "Full House": [9, 18, 27, 36, 45],
            Flush: [6, 12, 18, 24, 30],
            Straight: [4, 8, 12, 16, 20],
            "Three of a Kind": [3, 6, 9, 12, 15],
            "Two Pair": [2, 4, 6, 8, 10],
            "Jacks or Better": [1, 2, 3, 4, 5],
          },
        },
      };

      let currentPaytable = "full";

      // Initialize game
      function init() {
        console.log("üöÄ Game initialized");
        updateDisplay();
        setupEventListeners();
        buildPaytable();
      }

      // Update all display elements
      function updateDisplay() {
        document.getElementById("credits").textContent = gameState.credits;
        document.getElementById("bet").textContent = gameState.bet;
        document.getElementById("winnings").textContent = gameState.currentWin;
        document.getElementById("hands").textContent = gameState.handsPlayed;

        // Calculate session
        gameState.sessionNet = gameState.credits - gameState.startingCredits;
        const sessionEl = document.getElementById("session");
        if (gameState.sessionNet > 0) {
          sessionEl.textContent = `+${gameState.sessionNet}`;
          sessionEl.style.color = "#4ecdc4";
        } else if (gameState.sessionNet < 0) {
          sessionEl.textContent = `${gameState.sessionNet}`;
          sessionEl.style.color = "#e74c3c";
        } else {
          sessionEl.textContent = "0";
          sessionEl.style.color = "#4ecdc4";
        }
      }

      // Setup event listeners
      function setupEventListeners() {
        document.getElementById("deal").addEventListener("click", deal);
        document.getElementById("drawBtn").addEventListener("click", draw);
        document.getElementById("betOne").addEventListener("click", betOne);
        document.getElementById("betMax").addEventListener("click", betMax);
        document
          .getElementById("resetBtn")
          .addEventListener("click", resetCredits);

        // Simulation controls
        document
          .getElementById("startSim")
          .addEventListener("click", startSimulation);
        document
          .getElementById("stopSim")
          .addEventListener("click", stopSimulation);

        // Card clicks
        document
          .getElementById("cardsContainer")
          .addEventListener("click", handleCardClick);
      }

      // Create and shuffle deck
      function createDeck() {
        gameState.deck = [];
        for (let suit of suits) {
          for (let rank of ranks) {
            gameState.deck.push({ rank, suit });
          }
        }

        // Shuffle using Fisher-Yates algorithm
        for (let i = gameState.deck.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [gameState.deck[i], gameState.deck[j]] = [
            gameState.deck[j],
            gameState.deck[i],
          ];
        }
      }

      // Deal new hand
      function deal() {
        if (gameState.credits < gameState.bet) {
          document.getElementById("handResult").textContent =
            "Insufficient credits!";
          return;
        }

        console.log("=== DEALING NEW HAND ===");

        // Deduct bet
        gameState.credits -= gameState.bet;
        gameState.currentWin = 0;
        gameState.heldCards.clear();

        // Create new deck and deal
        createDeck();
        gameState.currentHand = [];
        for (let i = 0; i < 5; i++) {
          gameState.currentHand.push(gameState.deck.pop());
        }

        console.log(
          "Dealt:",
          gameState.currentHand.map((c) => `${c.rank}${c.suit}`).join(", ")
        );

        // Update game state
        gameState.gamePhase = "holding";
        document.getElementById("handResult").textContent =
          "Select cards to hold, then press DRAW";

        // Update buttons
        document.getElementById("deal").disabled = true;
        document.getElementById("drawBtn").disabled = false;
        document.getElementById("betOne").disabled = true;
        document.getElementById("betMax").disabled = true;

        renderCards();
        updateDisplay();
      }

      // Handle card clicks for holding
      function handleCardClick(event) {
        const card = event.target.closest(".card");
        if (!card || gameState.gamePhase !== "holding") return;

        const index = parseInt(card.dataset.index);

        if (gameState.heldCards.has(index)) {
          gameState.heldCards.delete(index);
          console.log(`Released hold on card ${index + 1}`);
        } else {
          gameState.heldCards.add(index);
          console.log(`Holding card ${index + 1}`);
        }

        renderCards();
      }

      // Draw replacement cards
      function draw() {
        console.log("=== DRAWING CARDS ===");

        // Replace non-held cards
        for (let i = 0; i < 5; i++) {
          if (!gameState.heldCards.has(i)) {
            gameState.currentHand[i] = gameState.deck.pop();
          }
        }

        console.log(
          "Final hand:",
          gameState.currentHand.map((c) => `${c.rank}${c.suit}`).join(", ")
        );

        // Evaluate hand
        const result = evaluateHand();
        const payout = calculatePayout(result.category);

        gameState.currentWin = payout;
        gameState.handsPlayed++;

        if (payout > 0) {
          gameState.credits += payout;
          document.getElementById(
            "handResult"
          ).textContent = `${result.description} - WIN ${payout} CREDITS!`;
          document.getElementById("handResult").style.color = "#4ecdc4";
          highlightPaytable(result.category);
        } else {
          document.getElementById(
            "handResult"
          ).textContent = `${result.description} - No Win`;
          document.getElementById("handResult").style.color = "#ff6b6b";
        }

        console.log(`Result: ${result.description}, Payout: ${payout}`);

        // Update game state
        gameState.gamePhase = "finished";
        document.getElementById("deal").disabled = false;
        document.getElementById("drawBtn").disabled = true;
        document.getElementById("betOne").disabled = false;
        document.getElementById("betMax").disabled = false;

        renderCards();
        updateDisplay();

        // Clear highlights after delay
        setTimeout(() => {
          clearPaytableHighlights();
          gameState.heldCards.clear();
          renderCards();
        }, 3000);
      }

      // Render cards on screen
      function renderCards() {
        const cards = document.querySelectorAll(".card");

        cards.forEach((cardEl, index) => {
          const card = gameState.currentHand[index];

          if (
            card &&
            (gameState.gamePhase === "holding" ||
              gameState.gamePhase === "finished")
          ) {
            // Show card face
            cardEl.className = "card";
            if (card.suit === "‚ô•" || card.suit === "‚ô¶") {
              cardEl.classList.add("red");
            }
            if (
              gameState.heldCards.has(index) &&
              gameState.gamePhase === "holding"
            ) {
              cardEl.classList.add("held");
            }

            cardEl.innerHTML = `
                        <div class="hold-indicator">HELD</div>
                        <div class="card-value">${card.rank}</div>
                        <div class="card-suit">${card.suit}</div>
                        <div class="card-value" style="transform: rotate(180deg);">${card.rank}</div>
                    `;
          } else {
            // Show card back
            cardEl.className = "card card-back";
            cardEl.innerHTML = '<div class="hold-indicator">HELD</div>';
          }
        });
      }

      // Evaluate poker hand
      function evaluateHand() {
        const ranks = gameState.currentHand.map(
          (card) => rankValues[card.rank]
        );
        const suits = gameState.currentHand.map((card) => card.suit);

        // Count ranks
        const rankCounts = {};
        ranks.forEach((rank) => {
          rankCounts[rank] = (rankCounts[rank] || 0) + 1;
        });

        const counts = Object.values(rankCounts).sort((a, b) => b - a);
        const isFlush = new Set(suits).size === 1;

        // Check straight
        const sortedRanks = [...new Set(ranks)].sort((a, b) => a - b);
        let isStraight = false;

        if (sortedRanks.length === 5) {
          isStraight = sortedRanks[4] - sortedRanks[0] === 4;
          // A-2-3-4-5 straight
          if (!isStraight && sortedRanks.join(",") === "1,2,3,4,5") {
            isStraight = true;
          }
          // 10-J-Q-K-A straight
          if (!isStraight && sortedRanks.join(",") === "1,10,11,12,13") {
            isStraight = true;
          }
        }

        // Royal flush
        const isRoyal =
          isStraight && isFlush && sortedRanks.join(",") === "1,10,11,12,13";

        // Determine hand
        if (isRoyal)
          return { category: "Royal Flush", description: "Royal Flush" };
        if (isStraight && isFlush)
          return { category: "Straight Flush", description: "Straight Flush" };
        if (counts[0] === 4)
          return { category: "Four of a Kind", description: "Four of a Kind" };
        if (counts[0] === 3 && counts[1] === 2)
          return { category: "Full House", description: "Full House" };
        if (isFlush) return { category: "Flush", description: "Flush" };
        if (isStraight)
          return { category: "Straight", description: "Straight" };
        if (counts[0] === 3)
          return {
            category: "Three of a Kind",
            description: "Three of a Kind",
          };
        if (counts[0] === 2 && counts[1] === 2)
          return { category: "Two Pair", description: "Two Pair" };
        if (counts[0] === 2) {
          const pairRank = Object.keys(rankCounts).find(
            (rank) => rankCounts[rank] === 2
          );
          if (pairRank == 1 || pairRank >= 11) {
            return {
              category: "Jacks or Better",
              description:
                "Pair of " +
                (pairRank == 1
                  ? "Aces"
                  : pairRank == 11
                  ? "Jacks"
                  : pairRank == 12
                  ? "Queens"
                  : "Kings"),
            };
          }
          return { category: "Low Pair", description: "Low Pair" };
        }

        return { category: "High Card", description: "High Card" };
      }

      // Calculate payout
      function calculatePayout(category) {
        const payouts = paytables[currentPaytable].payouts;
        if (payouts[category]) {
          return payouts[category][gameState.bet - 1];
        }
        return 0;
      }

      // Bet functions
      function betOne() {
        if (
          gameState.gamePhase !== "ready" &&
          gameState.gamePhase !== "finished"
        )
          return;
        gameState.bet = Math.min(gameState.bet + 1, 5);
        updateDisplay();
      }

      function betMax() {
        if (
          gameState.gamePhase !== "ready" &&
          gameState.gamePhase !== "finished"
        )
          return;
        gameState.bet = 5;
        updateDisplay();
        deal();
      }

      function resetCredits() {
        const newCredits = parseInt(
          document.getElementById("resetCredits").value
        );
        if (newCredits >= 100 && newCredits <= 10000) {
          gameState.credits = newCredits;
          gameState.startingCredits = newCredits;
          gameState.handsPlayed = 0;
          gameState.sessionNet = 0;
          updateDisplay();
        }
      }

      // Paytable functions
      function buildPaytable() {
        const grid = document.getElementById("paytableGrid");
        const paytable = paytables[currentPaytable];

        Object.entries(paytable.payouts).forEach(([hand, payouts]) => {
          const handEl = document.createElement("div");
          handEl.className = "paytable-row paytable-hand";
          handEl.textContent = hand;
          grid.appendChild(handEl);

          payouts.forEach((payout) => {
            const payoutEl = document.createElement("div");
            payoutEl.className = "paytable-row";
            payoutEl.textContent = payout;
            grid.appendChild(payoutEl);
          });
        });
      }

      function highlightPaytable(category) {
        const rows = document.querySelectorAll(".paytable-row");
        rows.forEach((row) => {
          if (row.textContent.trim() === category) {
            let currentRow = row;
            currentRow.classList.add("winning");
            for (let i = 0; i < 5; i++) {
              currentRow = currentRow.nextElementSibling;
              if (currentRow) currentRow.classList.add("winning");
            }
          }
        });
      }

      function clearPaytableHighlights() {
        document
          .querySelectorAll(".winning")
          .forEach((row) => row.classList.remove("winning"));
      }

      // SIMULATION FUNCTIONS
      function startSimulation() {
        console.log("üé∞ Starting simulation");

        // Get simulation parameters
        const handsInput =
          parseInt(document.getElementById("simHands").value) || 1000;
        const speedInput =
          parseInt(document.getElementById("simSpeed").value) || 10;
        const strategy = document.getElementById("simStrategy").value;

        // Validate inputs
        if (handsInput < 100 || handsInput > 100000) {
          alert("Number of hands must be between 100 and 100,000");
          return;
        }

        if (speedInput < 1 || speedInput > 1000) {
          alert("Speed must be between 1 and 1000 ms");
          return;
        }

        // Reset simulation state
        simState = {
          running: true,
          hands: 0,
          totalHands: handsInput,
          wagered: 0,
          won: 0,
          strategy: strategy,
          handCounts: {
            "Royal Flush": 0,
            "Straight Flush": 0,
            "Four of a Kind": 0,
            "Full House": 0,
            Flush: 0,
            Straight: 0,
            "Three of a Kind": 0,
            "Two Pair": 0,
            "Jacks or Better": 0,
            "No Win": 0,
          },
          winningHands: 0,
          timeoutId: null,
          netHistory: [0], // Start at 0
          graphData: [],
        };

        // Update UI
        document.getElementById("startSim").disabled = true;
        document.getElementById("stopSim").disabled = false;
        document.getElementById("progressContainer").classList.add("active");
        document.getElementById("simulationGraph").style.display = "none"; // Hide graph during simulation

        // Reset progress display
        document.getElementById("progressFill").style.width = "0%";
        document.getElementById("progressFill").textContent = "0%";

        // Update current hand display
        document.getElementById("currentHand").innerHTML = `
                <div style="color: #f39c12; font-weight: bold; font-size: 1.2em;">
                    üé∞ SIMULATION STARTING! üé∞<br>
                    ${handsInput.toLocaleString()} hands at ${speedInput}ms per hand
                </div>
            `;

        // Start simulation loop
        runSimulationLoop(speedInput);
      }

      function stopSimulation() {
        console.log("üõë Stopping simulation");
        simState.running = false;

        if (simState.timeoutId) {
          clearTimeout(simState.timeoutId);
          simState.timeoutId = null;
        }

        finishSimulation();
      }

      function runSimulationLoop(speed) {
        if (!simState.running || simState.hands >= simState.totalHands) {
          finishSimulation();
          return;
        }

        // Simulate one poker hand
        const handResult = simulatePokerHand();

        // Update simulation statistics
        simState.hands++;
        simState.wagered += 5; // Always bet 5 in simulation
        simState.won += handResult.payout;
        simState.handCounts[handResult.result.category]++;

        // Track net result for graphing
        const currentNet = simState.won - simState.wagered;
        simState.netHistory.push(currentNet);

        // Store data points for graph (sample every N hands for performance)
        const sampleRate = Math.max(1, Math.floor(simState.totalHands / 500)); // Max 500 points
        if (
          simState.hands % sampleRate === 0 ||
          simState.hands === simState.totalHands
        ) {
          simState.graphData.push({
            hand: simState.hands,
            net: currentNet,
          });
        }

        if (handResult.payout > 0) {
          simState.winningHands++;
        }

        // Update progress every 10 hands for performance
        if (
          simState.hands % 10 === 0 ||
          simState.hands === simState.totalHands
        ) {
          updateSimulationDisplay(handResult);
        }

        // Continue simulation
        simState.timeoutId = setTimeout(() => runSimulationLoop(speed), speed);
      }

      function simulatePokerHand() {
        // Create a real deck and deal a real hand
        createDeck();
        const initialHand = [];
        for (let i = 0; i < 5; i++) {
          initialHand.push(gameState.deck.pop());
        }

        // Determine holds based on strategy
        let holds;
        if (simState.strategy === "optimal") {
          holds = getOptimalHolds(initialHand);
        } else {
          holds = getRandomHolds();
        }

        // Create final hand by replacing non-held cards
        const finalHand = [...initialHand];
        for (let i = 0; i < 5; i++) {
          if (!holds.has(i)) {
            finalHand[i] = gameState.deck.pop();
          }
        }

        // Evaluate the final hand
        const tempHand = gameState.currentHand;
        gameState.currentHand = finalHand;
        const result = evaluateHand();
        const payout = calculatePayout(result.category);
        gameState.currentHand = tempHand;

        return {
          initialHand,
          finalHand,
          holds: Array.from(holds),
          result,
          payout,
        };
      }

      function getOptimalHolds(hand) {
        // Simplified optimal strategy for Jacks or Better
        const holds = new Set();
        const ranks = hand.map((card) => rankValues[card.rank]);
        const suits = hand.map((card) => card.suit);

        // Count ranks and suits
        const rankCounts = {};
        const suitCounts = {};
        ranks.forEach(
          (rank) => (rankCounts[rank] = (rankCounts[rank] || 0) + 1)
        );
        suits.forEach(
          (suit) => (suitCounts[suit] = (suitCounts[suit] || 0) + 1)
        );

        // Check for existing made hands
        const pairs = Object.keys(rankCounts).filter(
          (rank) => rankCounts[rank] === 2
        );
        const trips = Object.keys(rankCounts).filter(
          (rank) => rankCounts[rank] === 3
        );
        const quads = Object.keys(rankCounts).filter(
          (rank) => rankCounts[rank] === 4
        );

        // Priority 1: Four of a kind
        if (quads.length > 0) {
          const quadRank = parseInt(quads[0]);
          hand.forEach((card, i) => {
            if (rankValues[card.rank] === quadRank) holds.add(i);
          });
          return holds;
        }

        // Priority 2: Full house or three of a kind
        if (trips.length > 0 && pairs.length > 0) {
          return new Set([0, 1, 2, 3, 4]); // Hold full house
        }

        if (trips.length > 0) {
          const tripRank = parseInt(trips[0]);
          hand.forEach((card, i) => {
            if (rankValues[card.rank] === tripRank) holds.add(i);
          });
          return holds;
        }

        // Check for flush
        const flushSuit = Object.keys(suitCounts).find(
          (suit) => suitCounts[suit] >= 5
        );
        if (flushSuit) {
          return new Set([0, 1, 2, 3, 4]);
        }

        // Check for straight
        const sortedRanks = [...new Set(ranks)].sort((a, b) => a - b);
        const isStraight =
          sortedRanks.length === 5 &&
          (sortedRanks[4] - sortedRanks[0] === 4 ||
            sortedRanks.join(",") === "1,10,11,12,13" ||
            sortedRanks.join(",") === "1,2,3,4,5");
        if (isStraight) {
          return new Set([0, 1, 2, 3, 4]);
        }

        // Priority 3: High pairs (Jacks or better)
        const highPairs = pairs.filter((rank) => rank == 1 || rank >= 11);
        if (highPairs.length > 0) {
          const pairRank = parseInt(highPairs[0]);
          hand.forEach((card, i) => {
            if (rankValues[card.rank] === pairRank) holds.add(i);
          });
          return holds;
        }

        // Priority 4: Low pairs
        const lowPairs = pairs.filter((rank) => rank != 1 && rank < 11);
        if (lowPairs.length > 0) {
          const pairRank = parseInt(lowPairs[0]);
          hand.forEach((card, i) => {
            if (rankValues[card.rank] === pairRank) holds.add(i);
          });
          return holds;
        }

        // Priority 5: High cards (J, Q, K, A)
        const highCards = [];
        hand.forEach((card, i) => {
          if (rankValues[card.rank] === 1 || rankValues[card.rank] >= 11) {
            highCards.push(i);
          }
        });

        if (highCards.length > 0) {
          // Hold up to 3 high cards to avoid drawing too many
          highCards
            .slice(0, Math.min(3, highCards.length))
            .forEach((i) => holds.add(i));
          return holds;
        }

        // Default: Hold nothing (draw 5 new cards)
        return holds;
      }

      function getRandomHolds() {
        const holds = new Set();
        for (let i = 0; i < 5; i++) {
          if (Math.random() < 0.3) {
            // 30% chance to hold each card
            holds.add(i);
          }
        }
        return holds;
      }

      function updateSimulationDisplay(handResult) {
        // Update progress bar
        const progress = (simState.hands / simState.totalHands) * 100;
        document.getElementById("progressFill").style.width = `${progress}%`;
        document.getElementById(
          "progressFill"
        ).textContent = `${progress.toFixed(1)}%`;

        // Update current hand display
        document.getElementById("currentHand").innerHTML = `
                <div style="color: #f39c12; font-weight: bold; font-size: 1.2em;">
                    üé∞ SIMULATION RUNNING! üé∞<br>
                    Hand ${simState.hands.toLocaleString()} of ${simState.totalHands.toLocaleString()}
                </div>
                <div style="margin-top: 5px; font-size: 0.9em;">
                    Latest: ${handResult.finalHand
                      .map((c) => `${c.rank}${c.suit}`)
                      .join(" ")}<br>
                    Result: ${handResult.result.description} ${
          handResult.payout > 0 ? `(+${handResult.payout})` : "(0)"
        }
                </div>
            `;

        // Update statistics
        const net = simState.won - simState.wagered;
        const rtp =
          simState.wagered > 0 ? (simState.won / simState.wagered) * 100 : 0;
        const winRate =
          simState.hands > 0
            ? (simState.winningHands / simState.hands) * 100
            : 0;

        document.getElementById("simHandsPlayed").textContent =
          simState.hands.toLocaleString();
        document.getElementById("simWagered").textContent =
          simState.wagered.toLocaleString();
        document.getElementById("simWon").textContent =
          simState.won.toLocaleString();
        document.getElementById("simNet").textContent =
          (net >= 0 ? "+" : "") + net.toLocaleString();
        document.getElementById("simRTP").textContent = rtp.toFixed(2) + "%";
        document.getElementById("simWinRate").textContent =
          winRate.toFixed(1) + "%";

        // Update frequency table
        updateFrequencyTable();
      }

      function updateFrequencyTable() {
        const handTypes = [
          { key: "Royal Flush", id: "royal" },
          { key: "Straight Flush", id: "straight-flush" },
          { key: "Four of a Kind", id: "four-kind" },
          { key: "Full House", id: "full-house" },
          { key: "Flush", id: "flush" },
          { key: "Straight", id: "straight" },
          { key: "Three of a Kind", id: "three-kind" },
          { key: "Two Pair", id: "two-pair" },
          { key: "Jacks or Better", id: "jacks-better" },
          { key: "No Win", id: "no-win" },
        ];

        handTypes.forEach((handType) => {
          const count = simState.handCounts[handType.key] || 0;
          const frequency =
            simState.hands > 0 ? (count / simState.hands) * 100 : 0;

          const countEl = document.getElementById(`freq-${handType.id}`);
          const freqEl = document.getElementById(`freqp-${handType.id}`);

          if (countEl) countEl.textContent = count.toLocaleString();
          if (freqEl) freqEl.textContent = frequency.toFixed(2) + "%";
        });
      }

      function finishSimulation() {
        console.log("üèÅ Simulation complete");

        simState.running = false;

        if (simState.timeoutId) {
          clearTimeout(simState.timeoutId);
          simState.timeoutId = null;
        }

        // Reset buttons
        document.getElementById("startSim").disabled = false;
        document.getElementById("stopSim").disabled = true;

        // Calculate final stats
        const net = simState.won - simState.wagered;
        const rtp =
          simState.wagered > 0 ? (simState.won / simState.wagered) * 100 : 0;
        const winRate =
          simState.hands > 0
            ? (simState.winningHands / simState.hands) * 100
            : 0;

        // Show final results
        document.getElementById("currentHand").innerHTML = `
                <div style="color: #4ecdc4; font-weight: bold; font-size: 1.2em;">
                    ‚úÖ SIMULATION COMPLETE! ‚úÖ
                </div>
                <div style="margin-top: 10px; line-height: 1.4;">
                    <strong>Final Results:</strong><br>
                    ‚Ä¢ Hands Played: ${simState.hands.toLocaleString()}<br>
                    ‚Ä¢ Total Wagered: ${simState.wagered.toLocaleString()}<br>
                    ‚Ä¢ Total Won: ${simState.won.toLocaleString()}<br>
                    ‚Ä¢ Net Result: ${
                      net >= 0 ? "+" : ""
                    }${net.toLocaleString()}<br>
                    ‚Ä¢ Actual RTP: ${rtp.toFixed(2)}%<br>
                    ‚Ä¢ Win Rate: ${winRate.toFixed(1)}%<br>
                    ‚Ä¢ Strategy: ${simState.strategy}
                </div>
            `;

        // Show and render the results graph
        document.getElementById("simulationGraph").style.display = "block";
        renderResultsGraph();
      }

      function renderResultsGraph() {
        const canvas = document.getElementById("resultChart");
        const ctx = canvas.getContext("2d");

        // Set canvas size for crisp rendering
        const rect = canvas.getBoundingClientRect();
        canvas.width = rect.width * 2;
        canvas.height = rect.height * 2;
        ctx.scale(2, 2);

        const width = rect.width;
        const height = rect.height;
        const padding = 60;
        const graphWidth = width - padding * 2;
        const graphHeight = height - padding * 2;

        // Clear canvas
        ctx.fillStyle = "rgba(26, 26, 46, 0.9)";
        ctx.fillRect(0, 0, width, height);

        if (simState.graphData.length === 0) return;

        // Find min/max for scaling
        const maxHands = simState.totalHands;
        const netValues = simState.graphData.map((d) => d.net);
        const minNet = Math.min(0, ...netValues);
        const maxNet = Math.max(0, ...netValues);
        const netRange = maxNet - minNet || 1;

        // Draw grid lines
        ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
        ctx.lineWidth = 1;

        // Vertical grid lines
        for (let i = 0; i <= 10; i++) {
          const x = padding + (i * graphWidth) / 10;
          ctx.beginPath();
          ctx.moveTo(x, padding);
          ctx.lineTo(x, height - padding);
          ctx.stroke();
        }

        // Horizontal grid lines
        for (let i = 0; i <= 10; i++) {
          const y = padding + (i * graphHeight) / 10;
          ctx.beginPath();
          ctx.moveTo(padding, y);
          ctx.lineTo(width - padding, y);
          ctx.stroke();
        }

        // Draw baseline (zero line)
        const zeroY =
          padding + graphHeight - ((0 - minNet) / netRange) * graphHeight;
        ctx.strokeStyle = "#ffd700";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(padding, zeroY);
        ctx.lineTo(width - padding, zeroY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Draw the net result line
        ctx.strokeStyle =
          simState.graphData[simState.graphData.length - 1].net >= 0
            ? "#4ecdc4"
            : "#e74c3c";
        ctx.lineWidth = 3;
        ctx.beginPath();

        simState.graphData.forEach((point, index) => {
          const x = padding + (point.hand / maxHands) * graphWidth;
          const y =
            padding +
            graphHeight -
            ((point.net - minNet) / netRange) * graphHeight;

          if (index === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        });

        ctx.stroke();

        // Add gradient fill under the line
        const gradient = ctx.createLinearGradient(
          0,
          padding,
          0,
          height - padding
        );
        gradient.addColorStop(
          0,
          simState.graphData[simState.graphData.length - 1].net >= 0
            ? "rgba(78, 205, 196, 0.3)"
            : "rgba(231, 76, 60, 0.3)"
        );
        gradient.addColorStop(1, "rgba(78, 205, 196, 0.05)");

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.moveTo(padding, zeroY);
        simState.graphData.forEach((point, index) => {
          const x = padding + (point.hand / maxHands) * graphWidth;
          const y =
            padding +
            graphHeight -
            ((point.net - minNet) / netRange) * graphHeight;
          ctx.lineTo(x, y);
        });
        ctx.lineTo(width - padding, zeroY);
        ctx.closePath();
        ctx.fill();

        // Draw axes labels
        ctx.fillStyle = "#fff";
        ctx.font = "12px Orbitron";
        ctx.textAlign = "center";

        // X-axis labels (hands)
        for (let i = 0; i <= 5; i++) {
          const x = padding + (i * graphWidth) / 5;
          const hands = Math.round((i * maxHands) / 5);
          ctx.fillText(hands.toLocaleString(), x, height - padding + 20);
        }

        // Y-axis labels (net credits)
        ctx.textAlign = "right";
        for (let i = 0; i <= 5; i++) {
          const y = padding + graphHeight - (i * graphHeight) / 5;
          const netValue = Math.round(minNet + (i * netRange) / 5);
          ctx.fillText(
            netValue >= 0 ? `+${netValue}` : netValue.toString(),
            padding - 10,
            y + 4
          );
        }

        // Axis titles
        ctx.fillStyle = "#f39c12";
        ctx.font = "bold 14px Orbitron";
        ctx.textAlign = "center";
        ctx.fillText("Hands Played", width / 2, height - 10);

        ctx.save();
        ctx.translate(15, height / 2);
        ctx.rotate(-Math.PI / 2);
        ctx.fillText("Net Credits", 0, 0);
        ctx.restore();

        // Final result indicator
        const finalNet = simState.graphData[simState.graphData.length - 1].net;
        const finalX = padding + graphWidth;
        const finalY =
          padding +
          graphHeight -
          ((finalNet - minNet) / netRange) * graphHeight;

        ctx.fillStyle = finalNet >= 0 ? "#4ecdc4" : "#e74c3c";
        ctx.beginPath();
        ctx.arc(finalX, finalY, 6, 0, 2 * Math.PI);
        ctx.fill();

        // Final value label
        ctx.fillStyle = "#fff";
        ctx.font = "bold 12px Orbitron";
        ctx.textAlign = "left";
        ctx.fillText(
          `Final: ${finalNet >= 0 ? "+" : ""}${finalNet}`,
          finalX + 10,
          finalY + 4
        );
      }

      // Start the game
      document.addEventListener("DOMContentLoaded", init);
    </script>
  </body>
</html>
